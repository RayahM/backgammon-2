/***************************************************************
JBackgammon (http://jbackgammon.sf.net)
 
Copyright (C) 2002
George Vulov <georgevulov@hotmail.com>
Cody Planteen <frostgiant@msn.com>
 
revised by Mike Roam, 2011


This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
 
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
****************************************************************/

/** 
 * File: board.java
 *
 * Description: This file contains the class for the backgammon board, 
 * keeping count how many pieces of which color are on each "point",
 * and providing moving and dice rolling. 
 */

 

import java.util.Random;

public class Board
{
    int howManyOnPoint[];
    int whichColorOnPoint[];

    static final int neutral = 0;
    static final int white = 1;
    static final int black = 2;

    boolean rolled = false;

    Random rdice;
    int dice1;
    int dice2;
    int white_bar = 0;
    int black_bar = 0;
    int white_bear = 0;
    int black_bear = 0;

    
    /**
     * Build a new game board
     */
    public Board()
    {
        howManyOnPoint = new int[25]; // 0..24?? why 25 points? Maybe 0th point is the bar?  Or for bearing off??
        whichColorOnPoint = new int[25];
        rdice = new Random();

        for (int i=0; i<=24; i++)
        {
            howManyOnPoint[i] = 0;
            whichColorOnPoint[i] = neutral;
        }
        /* makeStartingBoard( ); */  
        makeEasyHitStartingBoard( );
        
    } // board constructor
    
    
    
    
    
    /**
     * The regular starting position
     */
    public void makeStartingBoard( ) {
        setPoint(1, /* howMany */ 2, white); /* used to be 2 */
        setPoint(6, /* howMany */ 5, black);
        setPoint(8, /* howMany */ 3, black);
        setPoint(12, /* howMany */ 5, white);
        setPoint(13, /* howMany */ 5, black);
        setPoint(17, /* howMany */ 3, white);
        setPoint(19, /* howMany */ 5, white);
        setPoint(24, /* howMany */ 2, black);
    } //  makeStartingBoard( )
    
    
    
    /**
     * Starting position in which it is easy for players to hit each other
     * (Handy for testing!)
     */
    public void makeEasyHitStartingBoard( ) {
        setPoint(1, /* howMany */ 1, white); /* used to be 2 */
        setPoint(6, /* howMany */ 1, black);
        setPoint(8, /* howMany */ 1, black);
        setPoint(12, /* howMany */ 1, white);
        setPoint(13, /* howMany */ 1, black);
        setPoint(17, /* howMany */ 1, white);
        setPoint(19, /* howMany */ 1, white);
        setPoint(24, /* howMany */ 1, black);
    } //  makeEasyHitStartingBoard( )
    
    
    
    
    /** 
     * black and white each have removed 5 pieces already...
     */
    public void makeAlmostDoneGame( ) {
        setPoint(1, /* howMany */ 2, black); /* used to be 2 */
        setPoint(5, /* howMany */ 5, black);
        setPoint(6, /* howMany */ 3, black);
        
        setPoint(18, /* howMany */ 3, white);
        setPoint(19, /* howMany */ 5, white);
        setPoint(24, /* howMany */ 2, white);
    } // makeAlmostDoneGame
    

    /** 
    * Not sure whether point 0 is used in this implementation...
    * (See the JBackgammon.java file for rules of moves...)
    * Static so that other classes can use it without an instance, is my hope.
    */
    public static boolean legitPointNum( int pointNum ) {
        if ( (pointNum > -1) && (pointNum <= 24) )
        {
            return true;
        } else {
            return false;
        }
    } // legitPointNum( )

    
    /**
     * Tells us if a color is legal
     */
    public boolean legitColor( int color ) {
        if ( (color == neutral) || (color == black) || (color==white) )
        {
            return true;
        } else {
            return false;
        }
    } // legitColor( )
    

    /**
     * Tells us which color is on the specified point (black, white, or neutral)
     */
    public int getColorOnPoint(int pointNum)
    {
        if ( legitPointNum(pointNum) )
        {
            return whichColorOnPoint[pointNum];
        } else {
            System.out.println("Bad pointNum '" + pointNum + "' in getColorOnPoint( )");
            return 0;
        }
    } // getColorOnPoint

    
    public int getHowManyBlotsOnPoint(int pointNum)
    {
        if ( ! legitPointNum(pointNum)) {
            System.out.println("Bad pointNum '" + pointNum + "' in getHowManyBlotsOnPoint( )");
            return 0;
        } else {
            return howManyOnPoint[pointNum];        
        }
    } // getHowManyBlotsOnPoint( )






    /**
     * Specified point gets a number of pieces of specified color
     */
    public void setPoint(int pointNum, int howMany, int color)
    {
        if ( ! legitPointNum(pointNum) ) {
            System.out.println("Bad pointNum '" + pointNum + "' in setPoint( )");
        } else if ( (howMany < 0) || (howMany > 15) ) {
        
        
        /* ******* Hey, shouldn't we check that there aren't too many pieces ?? ****/
        
            System.out.println("Bad howMany pieces '" + howMany + "' in setPoint( )");
        } else if ( ! legitColor( color ) ) {
            System.out.println("Bad color '" + color + "' in setPoint( )");
        } else {
            howManyOnPoint[pointNum] = howMany;
            if (howMany==0) 
            {
                color=neutral;
            }
            whichColorOnPoint[pointNum] = color;
        } // legitPointNum
    } // setPoint( )
    

    public void rollDice()
    {
        dice1 = rdice.nextInt(6) + 1;
        dice2 = rdice.nextInt(6) + 1;
        rolled = true;
        System.out.println("I just rolled the dice and got " + dice1 + " and " + dice2 + "!");
    } // rollDice
    

    public int getDice1()
    {
        return dice1;
    } // getDice1

    
    public int getDice2()
    {
        return dice2;
    } // getDice2
    
    
/**
* Put both dice back to 0
*/
    public void resetDice()
    {
        dice1 = 0;
        dice2 = 0;
        rolled = false;
    } // resetDice
    

    /**
    * Moving to "bar" from the specified point.
    * Why is the point then getting set to color neutral? What if more pieces are there??
    */
    public void moveToBar(int pointNum)
    {
        if ( ! legitPointNum(pointNum)) {
            System.out.println("Bad pointNum '" + pointNum + "' in setPoint( )");
        } else {
            if (getColorOnPoint(pointNum)==white) 
            {
                white_bar++;
            } else {
                black_bar++; 
            }
            setPoint(pointNum, /* howMany */ 0, neutral);
        } // legitPointNum
    } // moveToBar


	/**
    * Says how how many moves left before black blots are all "beared off".
    * 
    * E.G. suppose there is one black blot on point 1: answer is 1
    * (But white counts the other way: final move for white is point 24.)
    */
    public int getBlackPipCount( )
    {
        int pipcount = 0;

        for (int i=1; i<=24; i++)   /* used to be i<25 */
        {
            if (getColorOnPoint(i)==black) 
            {
                pipcount += getHowManyBlotsOnPoint(i) * i;
            }
        }
        /* blots on the bar are 25 moves away from bearing off */
        pipcount += black_bar * 25; 

        System.out.println("Black pip count is " + pipcount);
        return pipcount;
    } // getBlackPipCount
    
    
    
    /**
    * Says how how many moves left before black blots are all "beared off".
    * 
    * At the start of the game we think this should be 162.
    * 
    * E.G. suppose there is one white blot on point 1: answer is 24.
    * (But black counts the other way: final move for black is point 1.)
    */
    public int getWhitePipCount( )
    {
        int pipcount = 0;

        for (int i=1; i<=24; i++)   /* used to be i<25 */
        {
            if (getColorOnPoint(i)==white) 
            {
                pipcount += getHowManyBlotsOnPoint(i) * (25 - i);
            }
        }
                /* blots on the bar are 25 moves away from bearing off */
        pipcount += white_bar * 25; 

        System.out.println("White pip count is " + pipcount);
        return pipcount;
    } // getWhitePipCount




    /**
    * Says how many black pieces are still on the board.
    * Doesn't seem to count any on the bar??
    */
    public int getBlack( )
    {
        int sum = 0;

        for (int i=1; i<=24; i++)   /* used to be i<25 */
        {
            if (getColorOnPoint(i)==black) 
            {
                sum += getHowManyBlotsOnPoint(i);
            }
        }

        System.out.println("There are currently " + sum + " black blots on the board");
        return sum;
    } // getBlack


    /**
    * Says how many white pieces are still on the board.
    */
    public int getWhite()
    {
        int sum = 0;

        for (int i=1; i<=24; i++)
        {
            if (getColorOnPoint(i)==white) 
            {
                sum += getHowManyBlotsOnPoint(i);
            }
        }

        return sum;
    } // getWhite


    /**
    * apparently pieces can't bear off until all 15 are on final 6 points?
    */
    public boolean canBearOff(int color)
    {
        int sum = 0;

        if (color==white)
        {   // add up the white pieces on last 6 points
            for (int i=19; i<=24; i++)
                {
                    if (getColorOnPoint(i)==white) 
                    {
                        sum += getHowManyBlotsOnPoint(i);
                    }
                }
                sum = sum + white_bear;
        } else if (color==black) {
            // add up black pieces on first 6 points
            for (int i=1; i<=6; i++)
            {
                if (getColorOnPoint(i)==black) 
                {
                    sum += getHowManyBlotsOnPoint(i);
                }
            }
            sum = sum + black_bear;
        } else {
            System.out.println("bad color param '"+ color + "' in canBearOff( )");
        }

        if (sum==15) {
            return true;         //There are 15 pieces in backgammon
        }
        return false;
    } // canBearOff
    

    public boolean onBar(int color)
    {
        if (color==white)
        {
            if (white_bar>0) 
            {
                return true;
            } else {
                return false;
            }
        } else if (color==black) {
            if (black_bar>0) 
            {
                return true;
            } else {
                return false;
            }
        }

        return false;
    } // onBar
    

    public void setDice(int roll1, int roll2)
    {
        dice1 = roll1;
        dice2 = roll2;
    } // setDice

} // class Board
