#BlueJ class context
comment0.params=newMyGame
comment0.target=Board(Game)
comment0.text=\n\ Build\ a\ new\ game\ board.\n\ I\ was\ considering\ having\ another\ constructor\ that\ takes\ numeric\ parameter\n\ of\ which\ test\ board\ you\ want,\ but\ realized\ it\ is\ not\ necessary\:\ it\ is\ \n\ so\ easy\ to\ tell\ a\ newly\ constructed\ board\ to\ merely\ b.makeBoardWithoutBlots(\ )\ \n\ or\ b.makeStartingBoard(\ )\ or\ b.makeAlmostDoneGame(\ )\ or\ b.make3BlotGame(\ )\!\n\ \n\ Can\ constructors\ throw\ exceptions?\ Shouldn't\ this\ be\ throwing?\n
comment1.params=newMyGame\ otherBoard
comment1.target=Board(Game,\ Board)
comment1.text=\n\ Copy\ constructor\ so\ that\ I\ can\ make\ duplicate\ boards\n\ Usage\ \ Board\ b2\ \=\ new\ Board(\ myBoard\ );\n\ ??\ Should\ I\ also\ implement\ clone(\ )\ ???\ Nah,\ online\ says\ bad\ implementation,\ subtle\ bugs.\n\ "Game"\ is\ here\ so\ other\ Games\ can\ copy\ boards\ from\ this\ board's\ game\n
comment10.params=
comment10.target=void\ make3BlotGame()
comment10.text=\ \n\ black\ on\ 20\ &\ 12,\ white\ on\ 4\ (has\ long\ way\ to\ go)\n\ note\:\ white\ ends\ past\ 24,\ black\ ends\ below\ 1.\n\ black\ has\ beared\ off\ 13\ blots,\ white\ has\ beared\ off\ 14\ blots\ already...\n
comment11.params=
comment11.target=void\ make3BlotGame2()
comment11.text=\ \n\ black\ on\ 14\ &\ 12,\ white\ on\ 4\ (has\ long\ way\ to\ go)\n\ note\:\ white\ ends\ past\ 24,\ black\ ends\ below\ 1.\n\ black\ has\ beared\ off\ 13\ blots,\ white\ has\ beared\ off\ 14\ blots\ already...\n
comment12.params=
comment12.target=void\ make4BlotGame()
comment12.text=\ \n\ black\ on\ 20\ &\ 12,\ whites\ on\ 16\n\ note\:\ white\ ends\ past\ 24,\ black\ ends\ below\ 1.\n\ black\ &\ white\ have\ beared\ off\ 13\ blots\ already...\n
comment13.params=
comment13.target=void\ makeBusyBarGame()
comment13.text=\ \n\ black\ on\ bar,\ and\ 4\ twice;\ white\ on\ bar\ twice\ and\ on\ 22\ twice\n\ note\:\ white\ ends\ past\ 24,\ black\ ends\ below\ 1.\n
comment14.params=
comment14.target=Dice\ getMyDice()
comment14.text=\n\ returns\ a\ copy\ of\ the\ dice\ \n
comment15.params=
comment15.target=java.util.ArrayList\ getHitsSoFar()
comment15.text=\n\ returns\ a\ copy,\ won't\ hurt\ the\ current\n
comment16.params=
comment16.target=void\ hitsSoFarBeEmpty()
comment16.text=\n\ erase\ the\ list\ of\ blots\ sent\ to\ the\ bar\n
comment17.params=playerColor\ oldPointNum\ newPointNum\ rollValue
comment17.target=void\ moveBlot(Player,\ int,\ int,\ int)
comment17.text=\n\ Is\ called\ by\ Game.doPartialMove(\ ),\ so\ can't\ be\ private.\n\ Moves\ blot\ from\ one\ position\ to\ another,\ modifying\ the\ board\ object.\n\ Doesn't\ check\ legality\ of\ move,\ doesn't\ check\ whether\ player\ is\ on\ bar,\n\ so\ shouldn't\ be\ called\ willy\ nilly\!\n\ \n\ Can\ move\ Blots\ in\ from\ bar,\ so\ is\ a\ partner\ with\ "moveToBar(\ )"\n\ There\ is\ selectABar(\ )...\ does\ it\ overlap\ if\ function?\n\ Or\ maybe\ there\ should\ be\ a\ "moveFromBar(\ )"\ that\ includes\ the\ middle\ of\ this\n\ and\ is\ called\ by\ this\ if\ necessary.\ Could\ moveFromBar\ be\ called\ by\ others?\n\ \n\ ??\ Hey,\ this\ is\ doing\ action\ equivalent\ to\ bearOff\ without\ using\ Board.bearOff(\ ),\n\ and\ not\ doing\ it\ as\ well\ as\ bearOff\ does.\n\ Board.doPartialMove(\ )\ calls\ moveBlot(\ )...\ either\ doPartialMove\ should\ call\n\ bearOff(\ )\ when\ necessary\ or\ this\ moveBlot(\ )\ should\ call\ bearOff...\n\ \n\ Game.receiveMove(\ )\ [when\ networked]\ might\ be\ calling\ this.\n\ Shouldn't\ they\ call\ bearOff(\ )\ if\ necessary\ and\ legit,\ instead??\n\ bearOff(\ )\ doesn't\ call\ moveBlot\:\ bearOff\ calls\ takeOneBlotOffPoint(oldPointNum);\n\ which\ uses\ setNumOfBlotsOnPoint(\ )\ internally\ and\ is\ equivalent\ to\n\ setNumOfBlotsOnPoint(oldPointNum,\ getHowManyBlotsOnPoint(oldPointNum,playerColor)\ -\ 1,playerColor);\n
comment18.params=playerColor\ destPointNum\ rollValue
comment18.target=void\ comeInFromBar(Player,\ int,\ int)
comment18.text=\n\ Yes,\ this\ should\ know\ which\ incoming\ point\ to\ land\ on.\n\ Why\ is\ there\ a\ startPointNum,\ isn't\ necessarily\ playerColor.getBarLoc(\ )\n
comment19.params=playerColor\ oldPointNum\ rollValue
comment19.target=void\ bearOff(Player,\ int,\ int)
comment19.text=\n\ Bear\ off\ a\ blot\ from\ oldPointNum.\n\ Sure\ hope\ that\ the\ caller\ has\ checked\ legitimacy\ of\ bearing\ off\!\n\ Is\ called\ by\ Game.actionPerformed\ in\ response\ to\ button\ press,\ does\n\ no\ checking\!\n\ This\ is\ the\ only\ caller,\ but\ Game.receiveMove(\ )\ should\ maybe\ call\ this.\n\ Board.moveBlot(\ )\ is\ doing\ bearOff\ without\ calling\ this\:\ maybe\ it\ ought\ to\ call\ this\!\n\ @param\ playerColor\ -\ instance\ of\ Player\ is\ black,\ white,\ or\ null\ when\ game\ unstarted.\n\ @param\ oldPointNum\ -\ point\ we're\ bearing\ off\ from\n\ @param\ rollValue\ -\ the\ value\ on\ the\ face\ of\ the\ dice\ (1..6),\ to\ help\ in\ marking\ dice\ used\n
comment2.params=
comment2.target=void\ makeBoardWithoutBlots()
comment2.text=\n\ make\ sure\ the\ bars\ and\ bears\ and\ points\ are\ all\ free\ of\ blots.\n\ Should\ this\ myDice.reset(\ );\ ??\ probably\n
comment20.params=playerColor\ oldPointNum
comment20.target=int\ whichDieValueUsedForBearOff(Player,\ int)
comment20.text=\n\ Now\ that\ bearOff(\ )\ is\ told\ which\ diceRollValue\ is\ being\n\ used,\ bearOff\ doesn't\ need\ to\ call\ this.\n\ This\ has\ a\ bug\ \n\ Called\ by\ bearOff(\ ),\ this\ marks\ one\ of\ the\ dice\ as\ used,\n\ and\ has\ to\ do\ some\ work\ to\ determine\ which\ one\ was\ used.\n
comment21.params=playerColor
comment21.target=void\ selectABar(Player)
comment21.text=\n\ Deal\ with\ player\ being\ on\ bar\ by\ marking\ possible\ escapes\ and\ forfeitTurn\ if\ there\ are\ none.\n\ This\ is\ automatically\ called\ by\ Game.doRoll(\ )\ \ \ if\ \ \ Board.onBar(Game.current_player)\n\ and\ doRoll\ otherwise\ checks\ whether\ a\ player\ canMove(\ )\ and\ \n\ forfeitTurns\ for\ them\ if\ they\ can't\ move\!\n\ startTurn\ ought\ to\ call\ this\ if\ necessary\n\ ??\ Does\ AI\ hear\ this?\ Respond?\n
comment22.params=
comment22.target=int\ getSelectedPointLoc()
comment22.text=\n\ When\ a\ point\ is\ selected\ by\ user,\ its\ number\ is\ stored\ in\ selectedPointLoc\n\ and\ aPointIsSelected\ becomes\ true.\n\ While\ a\ blot\ is\ moving,\ this\ remembers\ its\ original\ (starting)\ position.\n\ I'm\ trying\ to\ not\ use\ it\ much.\n
comment23.params=
comment23.target=boolean\ getAPointIsSelected()
comment23.text=\n\ When\ a\ point\ is\ selected\ by\ user,\ its\ number\ is\ stored\ in\ selectedPointLoc\n\ and\ aPointIsSelected\ becomes\ true.\n
comment24.params=newSelectedPointLoc\ playerColor
comment24.target=void\ setSelectedPointLoc(int,\ Player)
comment24.text=\n\ When\ a\ point\ is\ selected\ by\ user,\ its\ number\ is\ stored\ in\ selectedPointLoc\n\ and\ aPointIsSelected\ becomes\ true.\ To\ turn\ off\ this\ selection,\ use\n\ setSelectedPointLoc(NO_MOVE_SELECTED);\ //\ which\ also\ turns\ off\ "aPointIsSelected"\n\ While\ a\ blot\ is\ moving,\ this\ remembers\ its\ original\ (starting)\ position??\n\ Can\ select\ bar\ but\ not\ BearOffLoc.\n\ \n\ Either\ this\ has\ to\ know\ which\ die\ is\ involved,\ OR\ anybody\ who\ calls\ this\n\ must\ also\ call\ "setRelevantButtons"\n
comment25.params=whichDest
comment25.target=int\ getPotDest(int)
comment25.text=\n\ Of\ the\ 2\ potential\ destinations\ for\ the\ selected\ point\ (selectedPointLoc),\ \n\ tell\ us\ the\ Point\ that\ is\ reached\ by\ dest\ 'whichDest'\n\ \n\ potDest\ should\ be\ an\ array,\ or\ ArrayList\n\ \!\n\ Maybe\ this\ should\ be\ part\ of\ myDice??\n
comment26.params=playerColor\ whichDest\ newDestPointNum
comment26.target=void\ setPotDest(Player,\ int,\ int)
comment26.text=\n\ When\ a\ point\ with\ blot\ has\ been\ "selectAPoint"ed,\ the\ board\ remembers\ some\n\ potDest\ (potential\ destinations)\ which\ are\ the\ legal\ moves\ from\ the\ selected\ place.\n\ This\ might\ need\ to\ remember\ NO_MOVE_SELECTED,\ also.\n\ \n\ potDest\ should\ be\ an\ array,\ or\ ArrayList\!\n\ This\ is\ called\ by\ \n
comment27.params=rollVal
comment27.target=int\ whichPotDest(int)
comment27.text=\n\ When\ doubles,\ we\ can't\ ask\ dice\ which\ die\ has\ the\ value\ because\ they\ all\ do.\n\ Still\ want\ to\ distinguish\ potMove1\ from\ potMove2\ for\ displaying\ buttons\ onscreen.\n
comment28.params=playerColor
comment28.target=int\ getBar(Player)
comment28.text=\n\ how\ many\ blots\ of\ this\ color\ are\ on\ the\ bar,\ waiting\ to\ come\ back\ into\ the\ game.\n
comment29.params=playerColor
comment29.target=int\ howManyBlots(Player)
comment29.text=\n\ Tells\ how\ many\ blots\ (pieces)\ of\ a\ particular\ color\ are\ here\ \n\ (including\ on\ the\ bar,\ the\ bear,\ or\ the\ board).\n\ There\ are\ supposed\ to\ always\ be\ 15\ blots\ of\ each\ color\ in\ traditional\ backgammon.\ \n\ Used\ by\ "checkForBadNumberOfBlots(\ )\ to\ check\ possible\ corruption\ of\ board.\n
comment3.params=
comment3.target=void\ makeStartingBoard()
comment3.text=\n\ The\ regular\ normal\ starting\ position\ (15\ blots\ of\ each\ color)\n
comment30.params=playerColor
comment30.target=void\ checkForBadNumberOfBlots(Player)
comment30.text=\n\ Checks\ for\ legal\ number\ of\ white\ and\ black\ blots,\ compared\ to\ globals.\n
comment31.params=steps
comment31.target=boolean\ legitStepsNum(int)
comment31.text=\n\ This\ will\ mostly\ be\ used\ for\ partial\ moves?\n\ The\ biggest\ possible\ partial\ move\ is\ 6\ (diceHighNum).\n\ The\ smallest\ possible\ partial\ move\ is\ 1\ (or\ 0?\ if\ forfeitTurn?\ not\ really\ a\ "move")\n\ The\ biggest\ possible\ (full,\ non\ partial)\ move\ in\ standard\ backgammon\ is\ 24\:\ doubles\ of\ 6s.\n
comment32.params=pointNum
comment32.target=boolean\ legitPointNum(int)
comment32.text=\n\ This\ only\ accepts\ pointNumbers\ [1..(howManyPoints\=\=24)],\ \n\ NOT\ BEAR,\ NOT\ BAR\!\!\ not\ ILLEGAL_MOVE,\ not\ NO_MOVE_SELECTED\n\ If\ I\ make\ Classes\ for\ PointNum,\ StartLoc,\ EndLoc\n\ this\ would\ want\ to\ move\ there.\n
comment33.params=pointNum\ playerColor
comment33.target=boolean\ legitStartLoc(int,\ Player)
comment33.text=\n\ For\ deciding\ legality\ of\ starting\ place\ for\ a\ blot\ move.\ 1..24\ or\ barLoc\n\ Sad\ note\:\ doesn't\ check\ whether\ the\ player\ is\ actually\ ON\ that\ point\ now.\n\ More\ picky\ than\ legitEndLoc(\ )\ since\ not\ allowing\ BEAR\ nor\ PAST_BEAR.\n\ Good\ for\ error\ prevention\ of\ move\ math.\n\ \n\ Checks\ the\ playerColor.legitColor(\ )\ \n\ so\ callers\ don't\ have\ to\ if\ they\ don't\ want\ to.\n\ Picky\ about\ not\ allowing\ white\ on\ BLACK_BAR,\ etc.\n\ A\ blot\ might\ start\ on\ the\ bar\ or\ on\ a\ legit\ point.\n\ Not\ sure\ whether\ point\ 0\ is\ used\ in\ this\ implementation...\n\ (See\ the\ Game.java\ file\ for\ rules\ of\ moves...)\n\ Static\ so\ that\ other\ classes\ can\ use\ it\ without\ an\ instance.\n
comment34.params=pointNum\ playerColor
comment34.target=boolean\ legitEndLoc(int,\ Player)
comment34.text=\n\ if\ legitEndLoc(\ )\ is\ called\ without\ specifying\ boolean\ exact,\ assume\ NOT\ exact.\n
comment35.params=pointNum\ playerColor\ exact
comment35.target=boolean\ legitEndLoc(int,\ Player,\ boolean)
comment35.text=\n\ For\ verifying\ that\ there\ is\ such\ a\ place\ for\ a\ blot\ move,\n\ but\ doesn't\ tell\ us\ whether\ that\ place\ is\ blocked\ by\ opponents,\n\ and\ doesn't\ tell\ us\ if\ we're\ allowed\ to\ actually\ bear\ off.\n\ See\ "canLandOn(\ )"\ for\ that\ total\ legality\ checking\!\n\ \n\ Picky\ about\ color\ since\ black\ can't\ be\ on\ WHITE_BAR,\ etc.\n\ but\ moves\ can\ otherwise\ end\ anywhere\:\ on\ points,\ bar,\ bear,\ past_bear,\n\ so\ this\ isn't\ as\ picky\ as\ legitStartLoc(\ )\ which\ doesn't\ allow\ the\ BEAR\ and\ PAST_BEAR.\n\ \n\ Checks\ the\ Player.legitColor(\ playerColor.getColor(\ )\ )\ \n\ so\ callers\ don't\ have\ to\ if\ they\ don't\ want\ to.\n\ called\ by\ canLandOn(\ ),\ among\ others\n
comment36.params=startPoint\ steps\ playerColor
comment36.target=int\ endPointMovingFrom(int,\ int,\ Player)
comment36.text=\n\ This\ does\ the\ math\ of\ moving\:\ given\ a\ starting\ point\ &\ a\ roll\ distance\ (one\ die),\ \n\ tells\ the\ end\ of\ the\ move.\n\ Can\ return\ ILLEGAL_MOVE\ if\ trying\ to\ bear\ out\ when\ not\ legal,\n\ if\ trying\ to\ go\ past\ exact\ bear\ out\ when\ exact\ dice\ are\ required,\ or\n\ if\ landing\ on\ a\ point\ protected\ by\ opponent.\n\ For\ white,\ simple\ math\ in\ the\ middle\ of\ the\ board\ (endpoint\ \=\ start\ +\ steps)\n\ but\ trickier\ at\ the\ end\ since\ after\ final\ point\ is\ the\ bar.\n\ Positive\ numbers\ must\ be\ used\ for\ black,\ too.\ This\ knows\ for\ black\ to\ use\ \n\ subtraction\ behind\ the\ scenes.\ I'll\ throw\ exception\ for\ negative\ 'steps'\!\n\ This\ just\ calculates\ but\ doesn't\ actually\ try\ to\ move\ any\ blots.\n\ Is\ handy\ for\ creating\ partialMoves\ (which\ have\ start,\ roll,\ end\ ).\n\n\ Note\:\ The\ endpoint\ has\ been\ checked\ for\ legality.\n\ \n\ Maybe\ this\ could\ decide\ whether\ to\ return\ BEAR_OFF_LOC\ even\ when\ \n\ it\ is\ going\ PAST_BEAR_OFF_LOC,\ but\n\ for\ now\ I'll\ return\ BEAR_OFF_LOC\ for\ exact\ bear\ off\ and\ PAST_BEAR_OFF_LOC\ if\ overshooting...\n
comment37.params=startPoint\ endPoint\ roll\ playerColor\ board
comment37.target=boolean\ canBearOffFromPointWithRoll(int,\ int,\ int,\ Player,\ Board)
comment37.text=\n\ This\ was\ called\ by\ endPointMovingFrom(\ ),\ after\ \n\ endPoint\ has\ been\ fixed\ to\ be\ 1..24\ or\ BAR\ or\ BEAR\ or\ BEAR+\n\ but\ seems\ redundant\ with\ canBearOffWithLargerRolls\ so\ isn't\ being\ called\ right\ now\n
comment38.params=playerColor
comment38.target=boolean\ allUnusedDiceAreBiggerThanBearOffMoves(Player)
comment38.text=\n\ This\ isn't\ called\ by\ canBearOff(\ )\ which\ we\ call\ for\ quick\ disqualify\ check.\n\ Called\ by\ "canBearOffWithLargerRolls(\ )"\ when\ checking\ that\ ALL\ of\ the\ (unused)\ dice\ \n\ are\ too\ big\ for\ any\ of\ our\ blots\ to\ bear\ off.\n
comment39.params=endPoint\ playerColor\ board
comment39.target=int\ fixOutOfBounds(int,\ Player,\ Board)
comment39.text=\n\ This\ is\ called\ by\ endPointMovingFrom(\ )\ in\ order\n\ to\ make\ sure\ destinations\ (pointNums)\n\ are\ re-declared\ as\ BAR\ and\ BEAR\ constants\n\ if\ out-of-bounds.\n
comment4.params=
comment4.target=void\ makePointBuild1Board()
comment4.text=\n\ A\ few\ moves\ have\ happened,\ for\ math\ demo\n
comment40.params=color
comment40.target=boolean\ legitColor(int)
comment40.text=\n\ Tells\ us\ if\ a\ color\ is\ legal\ (black,\ white,\ neutral)\n\ Use\ "Player.legitColor(\ )"\ if\ you\ want\ to\ check\ for\ only\ black\ and\ white\!\n\ "Player.legitColor(\ )"\ used\ to\ be\ "Board.legitPlayerColor(\ )"\n\ \n\ Note\:\ the\ neutral,\ black\ and\ white\ in\ Board\ class\ are\ Player\ pointers,\ not\ ints\!\n\ The\ neutral,\ black\ and\ white\ in\ GAME\ class,\ however,\ are\ ints.\ This\ might\ be\ bad.\n
comment41.params=color
comment41.target=java.lang.String\ colorName(int)
comment41.text=\n\ Utility\ for\ toString\ of\ our\ 3\ colors\ (black,white,neutral)\n\ Player\ has\ a\ version\ of\ this\ with\ just\ black\ and\ white.\n\ Note\:\ the\ neutral,\ black\ and\ white\ in\ Board\ class\ are\ Player\ pointers,\ not\ ints\!\n\ The\ neutral,\ black\ and\ white\ in\ GAME\ class,\ however,\ are\ ints.\ This\ might\ be\ bad.\n
comment42.params=pointNum
comment42.target=Player\ getPlayerOnPoint(int)
comment42.text=\n\ Tells\ us\ which\ color\ is\ on\ the\ specified\ point\ (Player\ black,\ white,\ or\ (null)neutral).\n\ This\ can't\ be\ used\ for\ BAR\ and\ BEAR_OFF\ zones\!\n\ Maybe\ it\ should\ be\ allowed\ to\ do\ BAR\ and\ BEAR\ ...\ but\ would\ have\ to\ be\ given\ a\ color\n\ then\ so\ that\ we\ knew\ which\ BAR/BEAR\ to\ look\ at.\ Yuck.\n
comment43.params=pointNum\ playerColor
comment43.target=Player\ getPlayerOnPoint(int,\ Player)
comment43.text=\n\ Tells\ us\ which\ color\ is\ on\ the\ specified\ point\ (black,\ white,\ [??or\ neutral??]).\n\ Unlike\ getPlayerOnPoint(ptNum)\ this\ can\ be\ used\ for\ BAR\ and\ BEAR_OFF\ zones\!\n\ If\ we\ know\ a\ color,\ why\ are\ we\ asking?\ Because\ this\ works\ for\ checking\ bar/bear.\n
comment44.params=pointNum\ playerColor
comment44.target=int\ getHowManyBlotsOnPoint(int,\ Player)
comment44.text=\n\ might\ return\ 0\n\ This\ is\ more\ specific\ alternative\ to\ getHowManyBlotsOnPoint(int\ pointNum)\n\ I\ suppose\ this\ is\ okay\ reporting\ back\ about\ BAR\ and\ BEAR??\n\ But\ there\ should\ never\ be\ any\ blots\ in\ the\ BeyondBearOffLoc\ so\ that\ should\ get\ exception??\n
comment45.params=pointNum
comment45.target=int\ getHowManyBlotsOnPoint(int)
comment45.text=\n\ Tells\ us\ how\ many\ blots\ without\ specifying\ their\ color.\n\ See\ alternative\ getHowManyBlotsOnPoint(int\ pointNum,\ Player\ playerColor)\n
comment46.params=startPointNum
comment46.target=void\ takeOneBlotOffPoint(int)
comment46.text=\n\ Convenience\ method\n\ What\ to\ do\ if\ there\ are\ no\ blots\ on\ the\ specified\ point?\ Uh-oh.\n\ This\ is\ only\ for\ points\ on\ the\ board\ (1..24),\ and\ maybe\ bar?\n
comment47.params=destPointNum\ howMany\ playerColor
comment47.target=void\ setNumOfBlotsOnPoint(int,\ int,\ Player)
comment47.text=\n\ This\ seems\ partly\ misnamed\:\ shouldn't\ it\ be\ "setNumOfBlotsOnPoint(\ )"??\n\ Specified\ point\ will\ end\ up\ holding\ "howMany"\ blots\ of\ specified\ color.\ \n\ (Might\ be\ 0\ blots\:\ cleared\ off,\ neutral).\ \n\ In\ that\ case\ any\ color\ is\ okay\:\ blackP,\ whiteP,\ null(means\ neutral).\n\ \n\ Might\ the\ board\ be\ temporarily\ having\ a\ bad\ number\ of\ blots\ while\ one\ is\ moving??\n\ Checking\ for\ legit\ END-point\ location,\ but\ have\ to\ treat\ bar\ special??\n\ \n\ ??\ We\ can\ put\ blots\ in\ the\ BearOffLoc,\ but\ not\ in\ the\ BeyondBearOffLoc??\ Or\n\ is\ BeyondBear\ OK\ when\ we\ need\ inexact\ dice?\n
comment48.params=pointNum\ bounceeColor
comment48.target=void\ moveToBar(int,\ Player)
comment48.text=\n\ Moving\ to\ "bar"\ from\ the\ specified\ point.\ (Checks\ that\ can't\ be\ coming\ from\ BEAR\ nor\ BAR\!)\n\ The\ point\ then\ getting\ set\ to\ color\ neutral\ because\ only\ a\ single\ can\ get\ sent\ to\ the\ bar.\n\ What\ if\ more\ blots\ are\ there\:\ bogus\ setup.\n\ This\ is\ called\ by\ moveBlot\ when\ hitting\ an\ opponent,\ and\ moveBlot\ sets\ a\ die\ used.\n\ There\ is\ equivalent\ "comeInFromBar(destPoint,\ playerColor\ )"\ method\n\ but\ "moveBlot(\ from,\ to,\ color)"\ also\ works\ when\ the\ fromLoc\ is\ a\ bar.\n
comment49.params=playerColor
comment49.target=int\ getPipCount(Player)
comment49.text=\n\ Says\ how\ how\ many\ moves\ left\ before\ black\ blots\ are\ all\ "beared\ off".\n\ \n\ E.G.\ suppose\ there\ is\ one\ black\ blot\ on\ point\ 1\:\ answer\ is\ 1\n\ (But\ white\ counts\ the\ other\ way\:\ final\ move\ on\ board\ for\ white\ is\ point\ 24.)\n\ This\ is\ equivalent\ to\ getBlackPipCount(\ )\ and\ getWhitePipCount(\ )\ but\ probably\n\ better\ since\ multi-purpose.\n
comment5.params=
comment5.target=void\ makePointBuildBoard()
comment5.text=\n\ AI\ isn't\ making\ the\ move\ we\ expect\ using\ pointBuilder\n
comment50.params=
comment50.target=int\ getBlackPipCount()
comment50.text=\n\ Says\ how\ how\ many\ moves\ left\ before\ black\ blots\ are\ all\ "beared\ off".\n\ This\ is\ equivalent\ to\ getPipCount(black),\ which\ is\ probably\ the\ better\ thing\ to\ use.\n\ \n\ E.G.\ suppose\ there\ is\ one\ black\ blot\ on\ point\ 1\:\ answer\ is\ 1\n\ (But\ white\ counts\ the\ other\ way\:\ final\ move\ on\ board\ for\ white\ is\ point\ 24.)\n
comment51.params=
comment51.target=int\ getWhitePipCount()
comment51.text=\n\ Says\ how\ how\ many\ moves\ left\ before\ black\ blots\ are\ all\ "beared\ off".\n\ This\ is\ equivalent\ to\ getPipCount(white),\ which\ is\ probably\ the\ better\ thing\ to\ use.\n\n\ At\ the\ start\ of\ the\ game\ we\ think\ this\ should\ be\ 162.\n\ \n\ E.G.\ suppose\ there\ is\ one\ white\ blot\ on\ point\ 1\:\ answer\ is\ 24.\n\ (But\ black\ counts\ the\ other\ way\:\ final\ move\ for\ black\ is\ point\ 1.)\n
comment52.params=
comment52.target=double\ protectionScoreWhite()
comment52.text=\n\ For\ comparing\ boards,\ thinking\ that\ protected\ points\ on\ certain\ parts\ of\ the\ board\n\ are\ more\ useful\ than\ on\ other\ parts\ of\ the\ board,\ and\ unprotected\ blots\ are\ in\ more\n\ danger\ in\ some\ places\ than\ in\ others.\n\ Writing\ this\ separately\ for\ white\ and\ black\ since\ they\ count\ up\ and\ down\ differently,\ \n\ unfortunately.\ Not\ sure\ if\ we're\ going\ to\ use\ this.\n
comment53.params=playerColor
comment53.target=int\ getHowManyUnprotected(Player)
comment53.text=\n\ Looks\ at\ all\ points\ to\ see\ if\ there\ are\ any\ loner\ blots\ who\ aren't\ protected.\n\ Note\:\ they\ might\ not\ be\ in\ danger\ if\ no\ enemies\ are\ nearby.\n\ Tells\ us\ how\ many\ of\ a\ color\ are\ unprotected.\n\ \n\ Might\ be\ useful\ for\ comparing\ boards.\ \ or\ might\ not\ matter....\n
comment54.params=playerColor
comment54.target=int\ getHowManyProtected(Player)
comment54.text=\n\ Looks\ at\ all\ points\ to\ see\ if\ there\ are\ any\ points\ who\ are\ protected.\n\ Tells\ us\ how\ many\ of\ a\ color\ are\ protected.\n\ Ought\ to\ care\ about\ where\ they\ are\ but\ doesn't.\n\ \n\ Might\ be\ useful\ for\ comparing\ boards.\n
comment55.params=
comment55.target=double\ getWhiteBeHitProbability()
comment55.text=\n\ Calculate\ white's\ total\ danger\ score,\ by\ figuring\n\ for\ every\ exposed\ white\ blots\ are\ there\n\ And\ how\ far\ away\ are\ black\ blots\ that\ could\ hit\ them\n\ AND\ how\ far\ are\ those\ white\ blots\ from\ the\ end??\ At\ least\ by\ quadrant?\n\ And\ do\ we\ care\ how\ far\ the\ exposed\ white\ blots\ are\ from\ eventual\ safety?\n\ \n\ Note\:\ white\ starts\ on\ 1\ and\ ends\ on\ 25\ (bear)\n
comment56.params=pointNum\ playerColor
comment56.target=int\ quadrantForPoint(int,\ Player)
comment56.text=\n\ Points\ 1..6\ are\ quadrant\ "1",\ 7..12\ \=\ q"2",\ for\ white,\ etc.\n\ This\ works\ for\ white\ and\ black\ (reverse\ the\ pointNum\ itself\ before\ calculating\ black).\n\ What\ about\ bar\ and\ bear?\ Bar\ is\ quadrant\ 1??\ or\ 0??\ Or\ don't\ matter\ for\ bar?\n\ Well,\ bar\ is\ definitely\ not\ 4,\ since\ all\ pieces\ have\ to\ be\ in\ 4\ to\ permit\ bearing\ off.\n\ [\ ]This\ would\ be\ better\ dividing\ by\ howManyPoints\ and\ taking\ floor?\n
comment57.params=pointNum
comment57.target=double\ blackCanHitPointProb(int)
comment57.text=\n\ for\ a\ particular\ point,\ what\ are\ the\ odds\ black\ can\ land\ on\ it.\n\ Unwritten,\ not\ in\ use\ yet.\n
comment58.params=pointNum\ playerColor
comment58.target=boolean\ solitaryBlotOnPoint(int,\ Player)
comment58.text=\n\ For\ a\ specific\ point,\ is\ there\ a\ solitary\ blot\ of\ color\ 'color'\ on\ it?\ \n\ (Unprotected,\ exposed\!)\n
comment59.params=pointNum\ playerColor
comment59.target=boolean\ isProtected(int,\ Player)
comment59.text=\ \n\ For\ a\ specific\ point,\ are\ there\ two\ or\ more\ blots\ of\ color\ 'color'\ on\ it?\ (Protected\!)\n\ Another\ way\ to\ ask\ this\ is\ "if\ (\ howMuchProtected(p,\ color)\ >\ 1)\ {..."\n
comment6.params=
comment6.target=void\ makePointBuild2Board()
comment6.text=\n\ A\ few\ moves\ have\ happened,\ for\ math\ demo\n
comment60.params=pointNum\ playerColor
comment60.target=int\ howMuchProtected(int,\ Player)
comment60.text=\n\ For\ a\ specific\ point,\ how\ many\ blots\ of\ color\ 'color'\ are\ on\ it?\ (Protected\!)\n\ Might\ return\ 0.\n\ Equivalent\ to\ getHowManyBlotsOnPoint(pointNum,\ playerColor);\n
comment61.params=playerColor
comment61.target=int\ getBlotCountOnBoard(Player)
comment61.text=\n\ Says\ how\ many\ blots\ of\ specified\ color\ are\ still\ on\ the\ board.\n\ Doesn't\ seem\ to\ count\ any\ on\ the\ bar??\n\ was\ called\ "getBlackOnBoard"\ and\ "getWhiteOnBoard"\n
comment62.params=playerColor
comment62.target=boolean\ canBearOff(Player)
comment62.text=\n\ player\ can't\ bear\ off\ until\ all\ (remaining)\ blots\ are\ on\ final\ 6\ points\ (final\ quadrant)\ \n\ or\ farther\ (i.e.\ already\ beared\ off).\n\ If\ onBar(\ )\ then\ can't\ bear\ off,\ so\ easy\ quick\ disqualify.\n\ Using\ the\ handy\ "getBlotCountOnBoard(\ playerColor\ );"\n
comment63.params=player1\ player2
comment63.target=boolean\ playersOverlap(Player,\ Player)
comment63.text=\n\ Checks\ whether\ any\ blots\ of\ player1\ are\ in\ the\ region\ of\ player2's\ blots.\n\ In\ two-player\ game,\ blots\ on\ bar\ can\ come\ so\ onBar\ automatically\ means\ overlap.\n
comment64.params=playerColor
comment64.target=int\ locOfLastBlot(Player)
comment64.text=\n\ Where\ is\ the\ farthest\ behind\ blot\ for\ this\ player\ (might\ be\ bar)\n\ Might\ be\ bear\ if\ all\ players\ are\ off\!?\n\ Can\ be\ used\ by\ AI.switchStrategy(\ )\ and\ Board.canBearOff(\ )\ and\ \n\ Board.playersDontOverlap(\ )\ and\ \n\ Board.allUnusedDiceAreBiggerThanBearOffMoves(\ )\n
comment65.params=playerColor
comment65.target=boolean\ onBar(Player)
comment65.text=\n\ True\ if\ specified\ color\ has\ any\ blots\ on\ the\ bar\n
comment66.params=playerColor
comment66.target=int\ howManyOnBar(Player)
comment66.text=\n\ How\ many\ blots\ of\ specified\ color\ are\ on\ its\ bar.\n\ Related\ to\ onBar(\ )\ which\ tells\ us\ (boolean)\ if\ ANY\ of\ the\ player's\ blots\ are\ on\ her\ bar\n
comment67.params=pointNum\ playerColor
comment67.target=void\ selectAPoint(int,\ Player)
comment67.text=\n\ Selects\ a\ point\ and\ shows\ the\ possible\ moves.\ This\ used\ to\ try\ both\n\ dice\ and\ do\ canMove(\ ),\ but\ now\ merely\ calls\ legalPartialMovesFromPoint(\ )\n\ which\ does\ the\ testing.\ This\ saves\ the\ legal\ moves\ and\ potDest1\ &\ potDest2\n\ and\ lights\ them\ up\ on\ the\ GUI.\n\ \n\ [\ ]This\ should\ be\ moved\ onto\ the\ user\ interface,\ serves\ to\ let\ human\ specify\ a\ move\n\ by\ "handling"\ a\ point\ (clicking\ on\ a\ point,\ and\ if\ there\ are\ blots\ on\ the\ point\ then\n\ this\ does\ several\ things\:\n\ --lights\ up\ potDest(n)\ buttons\ at\ the\ endpoints\ of\ legal\ partialMoves\n\ --store\ potDest1\ and\ potDest2\ as\ part\ of\ the\ board\n\ --tell\ the\ board\ to\ remember\ the\ selectedPointLoc\n\ --tell\ the\ board\ that\ "aPointIsSelected"\n\ This\ happens\ when\ current\ player\ clicks\ one\ of\ her\ own\ blots\:\ \n\ this\ calculates\ the\ potential\ moves\ (potDest1\ &\ potDest2)\ \n\ and\ displays\ the\ potential\ move\ buttons\ on\ the\ points\ that\ we\ can\ move\ this\ blot\ to.\n\ Memorizes\ the\ clicked\ upon\ point\ as\ "selectedPointLoc".\n\ ??\ Does\ this\ ensure\ that\ everybody\ is\ in\ from\ the\ bar??\ \n\ \ \ No,\ "selectABar"\ does\ that\ and\ is\ called\ by\ Board.doPartialMove(\ )\n
comment68.params=potentialDest\ playerColor\ isMove1or2
comment68.target=void\ setRelevantButtons(int,\ Player,\ int)
comment68.text=\n\ called\ by\ selectAPoint(\ ).\ If\ we're\ talking\ to\ the\ main\ (user\ visible)\ board\n\ turns\ on\ (&\ off?)\ GUI\ buttons\ \ "cancel\ choice",\ and/or\ the\ second\ move.\n\ The\ isMove1or2\ is\ for\ those\ "potential\ move"\ buttons\ that\ appear\ on\ gui.\n\ \n\ @param\ isMove1or2\ Can\ be\ 1\ or\ 2\ (for\ dice\ 1\ or\ dice\ 2)\ or\ 0\ means\ none\:\ hide'em\n
comment69.params=playerColor
comment69.target=boolean\ canBearOffWithLargerRolls(Player)
comment69.text=\n\ Returns\ whether\ the\ current\ player\ can't\ move\ anywhere\ else\n\ and\ needs\ to\ be\ able\ to\ bear\ off\ with\ an\ inexact\ roll\ \n\ BECAUSE\ all\ current\ dice\ are\ bigger\ than\ distance\ remaining\ for\ ALL\ blots.\n\ Doesn't\ actually\ tell\ us\ which\ roll\ we\ can\ use.\n\ Note\:\ still\ can't\ use\ small\ roll\ to\ bear\ off\ when\ higher\ blots\ exist\!\n\ temporarily\ unprivate\ so\ I\ can\ test\ it...\n\ was\ called\ "needsInexactRolls"\n
comment7.params=
comment7.target=void\ makeEasyHitStartingBoard()
comment7.text=\n\ Symmetrical\ starting\ position\ in\ which\ it\ is\ easy\ for\ players\ to\ hit\ each\ other\n\ white\ singles\ on\ 5,7,9,13\n\ black\ singles\ on\ (absolute)\ 20,18,16,12\ [from\ black\ POV\ \=\=\ 5,7,9,13]\n\ (Handy\ for\ testing\!)\n
comment70.params=playerColor
comment70.target=java.util.ArrayList\ allLegalPartialMoves(Player)
comment70.text=\n\ Uses\ method\ boolean\ canMove()\ and\ legalPartialMovesFromPoint(\ )\n\ both\ of\ which\ know\ that\ when\ a\ player\ is\ on\ the\ bar\ they\ can't\ move\ anywhere\!\n\ Perhaps\ using\ both\ is\ redundant.\n\ legalPartialMovesFromPoint(\ )\ takes\ of\ checking\ canLandOn(\ ).\n
comment71.params=startPoint\ playerColor
comment71.target=java.util.ArrayList\ legalPartialMovesFromPoint(int,\ Player)
comment71.text=\n\ Saving\ a\ list\ of\ the\ partial\ moves\ that\ can\ be\ made\ from\ a\ particular\ point.\n\ Might\ return\ empty\ list.\ \n\ Called\ by\ allLegalPartialMoves(\ )\ and\ by\ selectAPoint\ and\ canMove(\ )\n\ Only\ gets\ called\ if\ there\ are\ blots\ of\ myColor\ on\ myPoint,\ supposedly.\n\ This\ is\ counting\ on\ the\ move\ math\ calculator\ (endPointMovingFrom\:)\n\ to\ handle\ bar\ and\ bear\ properly,\ which\ it\ supposedly\ does.\n\ \n\ Formerly\ was\ doing\ selectAPoint(\ )\ to\ light\ up\ those\ "move\ here"\ buttons\n\ and\ then\ storing\ their\ locations\ (potDest1,\ potDest2).\ Now\ it\ is\ the\ other\ \n\ way\ around\:\ selectAPoint(\ )\ asks\ here\ for\ the\ list\ of\ legal\ moves\ of\ the\ \n\ selected\ point\ and\ stores\ them\ as\ potDest1\ &\ potDest2.\n\ \n\ probably\ works\ for\ bar\ (uses\ endPointMovingFrom\ which\ is\ cool\ with\ bar)\n
comment72.params=playerColor\ stepsSoFar
comment72.target=Move\ aLegalMove(Player,\ Move)
comment72.text=\n\ Calculate\ just\ one\ legal\ move.\ \n\ This\ is\ just\ an\ attempt\ to\ sneak\ up\ on\ designing\ "allLegalMoves(\ )".\n\ Not\ for\ real\ use\!\ Needs\ to\ loop\ as\ long\ as\ \!\ allDiceUsedUp\ so\ doubles\ are\ okay.\n\ Beware\:\ might\ return\ null.\ \ ??\ Should\ there\ be\ a\ nullMove\ object?\n\ Note\:\ this\ recurses\ until\ building\ and\ returning\ a\ "complete"\ move,\ using\ all\ the\ dice.\ \n\ This\ is\ not\ just\ a\ partial\ move\ (which\ use\ one\ die).\n\ \n\ ??\ doesn't\ use\ the\ stepsSoFar,\ wassup,\ incomplete\ design?\n\ ??\ does\ this\ have\ \n
comment73.params=myScorer\ partialsSoFar\ playerColor
comment73.target=MoveWithScore\ bestLegalMove(Scorer,\ java.util.ArrayList,\ Player)
comment73.text=\n\ My\ original\ plan\ was\ to\ get\ a\ collection\ of\ all\ legal\ moves\ so\ that\ AI\n\ could\ compare\ and\ choose\ from\ the\ resulting\ boards.\ As\ of\ 5\ May\ 2012\ I'm\n\ leaving\ allLegalMoves\ unwritten\ and\ instead\ focusing\ on\ writing\ this\ \n\ "bestLegalMove(\ )"\ that\ doesn't\ bother\ to\ save\ ALL\ of\ the\ possible\ tables.\ \n\ Instead,\ bestLegal\ can\ return\ the\ "best"\ move\ with\ the\ score\ of\ the\ resulting\ \n\ board,\ as\ determined\ by\ a\ Scorer\ object\ (or\ scoring\ function)\ that\ is\ passed\ in\ by\ AI.\n\ \n\ @param\ myScorer\ will\ be\ used\ to\ calculate\ values\ for\ boards\ we\ reach\n\ @param\ partialsSoFar\ the\ steps\ (partialMoves)\ in\ the\ move\ so\ far\ to\ build\ this\ board.\ \n\ (The\ caller\ is\ remembering\ the\ starting\ board.)\ Might\ be\ null\ if\ no\ partials\ so\ far.\n\ @param\ bestMoveSoFar\ CANCELLED\:\ each\ copy\ of\ this\ method\ will\ pick\ the\ best\ of\n\ its\ children\ and\ pass\ back\ the\ winner.\ Was\ going\ to\ be\ null\ at\ the\ start.\ \n\ \n\ Since\ Moves\ are\ tied\ to\ a\ starting\n\ board,\ Moves\ could\ conceivably\ hold\ a\ score\ field\ stating\ "the\ value\ of\ this\ move\n\ when\ applied\ to\ startingBoard\ and\ measured\ with\ scoring\ function\ S"...\ ??\ Then\n\ the\ Move\ would\ have\ to\ have\ a\ boolean\ hasBeenScored\ and\ a\ Scorer.\ For\ now\n\ I'm\ passing\ around\ the\ bestMoveSoFar\ and\ its\ corresponding\ score.\ The\ score\ of\ a\n\ null\ board\ should\ be\ ignored,\ and\ I'm\ not\ sure\ how\ to\ enforce\ this\ except\ by\n\ wiring\ it\ into\ the\ code\ here.\n
comment74.params=playerColor\ partialsSoFar
comment74.target=java.util.ArrayList\ allLegalMoves(Player,\ java.util.ArrayList)
comment74.text=\n\ Incomplete,\ untested,\ but\ might\ run.\n\ This\ was\ intended\ to\ provide\ a\ collection\ of\ all\ legal\ moves\ so\ that\ AI\n\ could\ compare\ and\ choose\ from\ the\ resulting\ boards.\ As\ of\ 5\ May\ 2012\ I'm\n\ leaving\ this\ unwritten\ and\ instead\ focusing\ on\ writing\ a\ "bestLegalMove(\ )"\n\ that\ doesn't\ bother\ to\ save\ ALL\ of\ the\ possible\ tables.\ Instead,\ bestLegal\n\ can\ return\ the\ "best"\ move\ with\ the\ score\ of\ the\ resulting\ board,\ as\n\ determined\ by\ a\ Scorer\ object\ (or\ scoring\ function)\ that\ is\ passed\ in\ by\ AI.\n\ \n\ Note\:\ the\ children\ must\ be\ given\ DUPLICATES\ of\ "partialsSoFar"\ so\ they\n\ don't\ squabble\ over\ changing\ the\ original.\ Shallow\ copy\ is\ okay,\ I\ think,\n\ since\ they\ won't\ be\ altering\ the\ PartialMove\ objects\ that\ it\ contains?\n\ \n\ Uses\ method\ boolean\ canMove(int\ color)\ which\ itself\ uses\ \n\ boolean\ canLandOn(int\ newPointNum,\ playerColor,\ /*exact???)???\ \n\ Beware\:\ with\ doubles\ (4\ partial\ moves)\ I\ think\ that\ 15\ blots\ provides\ \n\ up\ to\ 15^4\ possible\ moves\ \=\ 50,625.\n\ (Without\ doubles,\ there\ are\ up\ to\ 450\ possible\ moves\ (2*15^2)\ for\ each\ pair-of-dice\ roll.\n\ \n\ As\ a\ follow-up\ to\ this,\ I'm\ sketching\ allLegalResultingBoards(\ )\ above.\n\ \n\ flip-flopping\ between\ design\ styles\:\ \n\ (a)\ recursion,\ appending\ to\ (copy\ of)\ partialsSoFar\ and\ returning\ them\ in\ a\ move\ when\ stuck.\n\ (b)\ building\ a\ (global?)\ tree\ (Set\ of\ unique\ leaves)\ for\ later\ recursion.\n
comment75.params=pm
comment75.target=void\ doPartialMove(PartialMove)
comment75.text=\n\ Alternate\ calling\ overload\:\ breaks\ apart\ fields\ and\ passes\ them\ to\ old\ doPartialMove,\ to\n\ spare\ us\ from\ having\ to\ manufacture\ temporary\ PartialMoves\ in\ the\ button\ listeners.\n\ But\ that\ might\ not\ be\ so\ bad??\n
comment76.params=myMove\ playerColor
comment76.target=void\ doMove(Move,\ Player)
comment76.text=\n\ Combination\ of\ Move.doMove\ and\ Game.doMove,\ which\ have\ been\ removed.\n\ This\ calls\ Board.doPartialMove,\ and\ should\ save\ the\ latest\ move\n\ for\ undo\ and\ so\ the\ recentMove\ buttons\ know\ where\ to\ display.\n
comment77.params=fromPoint\ toPoint\ rollValue\ playerColor
comment77.target=void\ doPartialMove(int,\ int,\ int,\ Player)
comment77.text=\ \n\ Does\ "partialMove"\:\ use\ one\ die\ value\ to\ move\ one\ blot.\ \n\ (Was\ originally\ named\ 'superMove'.)\n\ @param\ fromPoint\ -\ where\ the\ blot\ is\ starting\ (might\ be\ 0\ (white\ bar)\ or\ 25\ (black\ bar))\n\ @param\ toPoint\ -\ the\ new\ position\ (point\ number)\ to\ move\ to.\n\ @param\ whichDie\ -\ which\ dice\ is\ being\ used,\ the\ first\ one\ or\ the\ second\ one.\n\ @param\ rollValue\ -\ the\ face\ of\ the\ die,\ (when\ bearing\ off\ might\ \!\=\ distance\ traveling)\n\ \n\ calls\ "Board.moveBlot(\ )"\ method\n\ There\ is\ a\ "myDice.getUsedDice(\ )"\ which\ says\ which\ partial\ moves\ \n\ (corresponding\ to\ which\ dice)\ have\ been\ used.\ \n\ myDice.isDoubles(\ );\ is\ true\ when\ doubles\ have\ been\ rolled,\ \n\ and\ myDice.allDiceAreUsed(\ )\ keeps\ track\ of\ moves\ countdown.\n\ \n\ Note\:\ if\ this\ is\ the\ final\ partial\ move\ on\ Game.mainBoard,\ \n\ this\ switches\ players\ by\ calling\ Game.endTurn(\ )\!\n\ This\ calls\ moveBlot(\ ),\ which\ checks\ the\ legality\ of\ the\ move.\n
comment78.params=pointNum\ playerColor
comment78.target=boolean\ canLandOn(int,\ Player)
comment78.text=\ \n\ Return\ whether\ the\ specified\ player\ can\ place\ a\ blot\ at\ a\ certain\ position.\n\ This\ checks\ whether\ moves\ can\ bear\ off\ with\ inexact\ dice.\n\ See\ "canLandOn(..\ Exact\ )"\ which\ only\ accepts\ precise\ moves\ matching\ dice\ roll.\n\ \n\ if\ they\ don't\ tell\ us\ whether\ we\ have\ to\ be\ exact,\ assume\ NOT\n
comment79.params=pointNum\ playerColor\ exact
comment79.target=boolean\ canLandOn(int,\ Player,\ boolean)
comment79.text=\ \n\ Return\ whether\ the\ specified\ player\ can\ place\ a\ blot\ at\ a\ certain\ position.\n\ This\ is\ supposedly\ specifying\ the\ endpoint\ of\ a\ move.\n\ See\ "canLandOn(\ )"\ which\ is\ like\ this\ but\ allows\ for\ bearing\ off\ with\ inexact\ dice\ rolls.\n\n\ Is\ this\ checking\ that\ nobody\ is\ still\ on\ the\ bar\ waiting\ to\ come\ in??\n\ Hmmm,\ this\ might\ be\ actually\ checking\ whether\ the\ blot\ on\ the\ bar\ can\ come\ in\ here,\n\ so\ don't\ be\ too\ negative\ about\ there\ being\ somebody\ on\ the\ bar\!\n\ was\ originally\ called\ "checkFair"\n
comment8.params=
comment8.target=void\ makeAlmostDoneGame()
comment8.text=\ \n\ black\ has\ singles\ in\ quadrant\ 4,\ on\ points\ 1,4,6\ (bearing\ off\ to\ 0)\n
comment80.params=playerColor
comment80.target=boolean\ canMove(Player)
comment80.text=\n\ If\ they\ don't\ tell\ us\ otherwise,\ "canMove"\ assumes\ we're\ NOT\ being\ exact.\n
comment81.params=playerColor\ exact
comment81.target=boolean\ canMove(Player,\ boolean)
comment81.text=\n\ With\ the\ current\ rolls,\ can\ the\ user\ move\ anywhere?\n\ Beware\:\ this\ calls\ "canBearOffWithLargerRolls()"\ which\ can\ either\ call\ \n\ this\ canMove()\ or\ does\ its\ equivalent??\ looping\ through\ all\ points\n\ This\ will\ call\ canMove(\ with\ exact\ true\ ),\ \n\ and\ if\ stuck\ then\ try\ canBearOff\ and\ canBearOffWithLargerRolls\n\n\ Notes\ for\ the\ exact\ version\:\n\ (Later\ we'll\ worry\ about\ whether\ inexact\ rolls\ are\ allowed.)\n\ Beware\:\ the\ broader\ "canMove"\ calls\ this\ and\ then\ calls\ "canBearOffWithLargerRolls()"\ \n\ if\ necessary.\n\ Watch\ out\ for\ either\ of\ them\ calling\ this\ canMoveExact()\ or\ does\ its\ equivalent??\ \n\ looping\ through\ all\ points.\n\n\ This\ used\ to\ have\ simple\ overflow/underflow\ move\ math\:\n\ \ if\ (playerColor\=\=white)\ {\ move1\ \=\ point\ +\ getDie(1);\ move2\ \=\ point\ +\ getDie(2);\n\ \ }\ else\ {\ move1\ \=\ point\ -\ getDie(1);\ move2\ \=\ point\ -\ getDie(2);\ }\n
comment82.params=pointNum\ playerColor\ exact
comment82.target=boolean\ blotsOnPointCanMove(int,\ Player,\ boolean)
comment82.text=\n\ Called\ by\ canMove(\ )\ for\ individual\ points.\n\ Tells\ us\ whether\ moveable\ blots\ _of_the_specified_color_\ are\ on\ the\ point.\n\ Isn't\ this\ partially\ duplicated\ by\ selectAPoint(\ )\ and\ allLegalPartialMoves(\ )\n\ or\ legalPartialMovesFromPoint(\ )??\n\ \n\ probably\ works\ for\ bar\ (uses\ endPointMovingFrom\ which\ is\ cool\ with\ bar)\n
comment83.params=playerColor
comment83.target=LocList\ allMoveableBlotLocs(Player)
comment83.text=\ \n\ Gives\ locations\ of\ moveable\ blots.\ Doesn't\ say\ how\ many\ are\ at\ each\ loc.\n\ If\ I\ have\ blots\ on\ the\ bar,\ they\ are\ the\ only\ moveables\!\n\ Beware\:\ black\ moves\ in\ negative\ direction\n\ and\ old\ version\ of\ game\ coded\ 0\ as\ black\ wanna-bear-off\ and\ 25\ as\ white\ wanna-bear-off.\n\ Shouldn't\ this\ encode\ HOW\ MANY\ moveable\ blots\ are\ at\ that\ location?\n\ \n\ Beware??\ This\ marks\ as\ moveable\ ANY\ blot,\ even\ if\ it\ has\ a\ wall\ of\ barricades\n
comment84.params=playerColor
comment84.target=boolean\ canOnlyMoveFromBar(Player)
comment84.text=\n\ With\ doubles\ we\ can\ possibly\ move\ 3\ blots\ in\ from\ bar\ and\ still\ have\ a\ 4th\ blot\ to\ move,\n\ and\ without\ doubles\ then\ we\ can\ move\ 1\ blot\ in\ from\ bar\ and\ still\ have\ a\ move\ left.\n\ This\ says\ whether\ we're\ stuck\ moving\ ONLY\ blots\ from\ the\ bar.\n\ used\ by\ "allMoveableBlotLocs(\ )"\n
comment85.params=other
comment85.target=boolean\ sameBlotLocations(Board)
comment85.text=\n\ For\ comparing\ just\ the\ blot\ locations\ on\ two\ boards.\n\ Doesn't\ care\ about\ similarity\ of\ "Game",\ "currentPlayer",\ dice,\ nor\ selected\ points.\n\ Is\ used\ by\ equals(\ ),\ which\ may\ or\ may\ not\ care\ about\ those\ other\ details.\n
comment86.params=other
comment86.target=boolean\ equals(java.lang.Object)
comment86.text=\n\ For\ comparing\ the\ layout\ of\ two\ boards.\n\ Doesn't\ care\ whether\ they're\ from\ the\ same\ "Game".\n\ Doesn't\ currently\ care\ about\ whether\ "currentPlayer"\ is\ the\ same??\ Should\ it?\n\ Does\ not\ care\ about\ whether\ dice\ are\ the\ same,\ nor\ whether\ a\ point\ is\ selected.\n
comment87.params=maxCharsOnLine
comment87.target=java.lang.String\ blotLocationsStr(int)
comment87.text=\n\ for\ toString,\ related\ to\ "sameBlotLocations"\ used\ by\ equals(\ )\n
comment88.params=
comment88.target=java.lang.String\ toString()
comment9.params=
comment9.target=void\ makeAlmostDonerGame()
comment9.text=\ \n\ black\ has\ singles\ in\ quadrant\ 4,\ on\ points\ 1,3,4\ (bearing\ off\ to\ 0)\n\ white\ has\ 3\ on\ 18\ &\ 19,\ and\ has\ 2\ on\ 24\n
numComments=89
